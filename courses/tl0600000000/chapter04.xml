<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"> 
<chapter type="" id="tl0604000000">
<title><content-text>Camada de Transporte OSI</content-text></title>
<section type="ChapterIntroduction" id="tl0604000000">
<title><content-text>Introdução ao Capítulo</content-text></title>
<topic type="" id="tl0604000100">
<title><content-text>Introdução ao Capítulo</content-text></title>
<page type="OneColumn" id="tl0604000101"><content-media type="StaticGraphic" id="cm3671155438"><title><content-text></content-text></title><media ref="tl0604000000/tl0604000000/tl0604000100/tl0604000101/cm3671155438.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604000000/tl0604000100/tl0604000101/cm3671155438text.xml"/></content-media> <content-text><p>As redes de dados e a Internet suportam a rede humana através do fornecimento de comunicação contínua e confiável entre pessoas localmente e ao redor do mundo. Através de um simples dispositivo, as pessoas podem usar múltiplos serviços como e-mail,  web e mensagens instantâneas para enviar mensagens ou recuperar informação. Aplicações como clientes de e-mail, navegadores e clientes de envio de mensagem instantânea permitem às pessoas usarem os computadores e redes para enviar mensagens e encontrar informação.</p><p>Dados de cada uma dessas aplicações são empacotadas, transportadas e entregues ao servidor daemon apropriado ou aplicação no dispositivo de destino. Os processos descritos na camada de Transporte do modelo OSI aceitam dados da Camada de Aplicação e os preparam para endereçamento na camada de Rede. A camada de Transporte é responsável pela transferência fim-a-fim geral de dados de aplicação. </p><p>Neste capítulo, nós examinaremos o papel da camada de Transporte no encapsulamento de dados de aplicação para uso pela camada de Rede. A camada de Transporte também abrange estas funções: </p><ul><li> Habilita a comunicação de múltiplas aplicações na rede ao mesmo tempo em um único dispositivo </li><li> Assegura que, se necessário, todos os dados sejam recebidos confiavelmente e em ordem pela aplicação correta.</li><li> Emprega mecanismos de tratamento de erros </li></ul><p><b>Objetivos</b></p><p>Após o término deste capítulo, você será capaz de:</p><ul><li> Explicar a necessidade da camada de Transporte.</li><li> Identificar o papel da camada de Transporte, visto que, ela proporciona a transferência fim-a-fim de dados entre aplicações.</li><li> Descrever o papel de dois protocolos TCP/IP da camada de Transporte: TCP e UDP.</li><li> Explicar as funções principais da camada de Transporte, incluindo confiabilidade, endereçamento de porta e segmentação.</li><li> Explicar como o TCP e o UDP gerenciam funções-chave.</li><li> Identificar quando é apropriado usar o TCP ou o UDP e apresentar exemplos de aplicações que usam cada um desses protocolos.</li></ul></content-text></page></topic></section> <section type="" id="tl0604010000">
<title><content-text>Funções da Camada de Transporte</content-text></title>
<topic type="" id="tl0604010100">
<title><content-text>Propósito da Camada de Transporte</content-text></title>
<page type="OneColumn" id="tl0604010101"><content-media type="StaticGraphic" id="cm3362687121"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010100/tl0604010101/cm3362687121.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010100/tl0604010101/cm3362687121text.xml"/></content-media> <content-text><p>A camada de Transporte proporciona a segmentação de dados e o controle necessário para reagrupar esses segmentos em fluxos de comunicação. Suas responsabilidades primárias para realizar isto são:</p><ul><li> Rastrear a comunicação individual entre as aplicações nos hosts de origem e destino.</li><li> Segmentar dados e gerenciar cada segmento</li><li> Reagrupar os segmentos em fluxos de dados de aplicação</li><li> Identificar as diferentes aplicações</li></ul><p><b>Rastreamento de Conversações Individuais</b></p><p>Qualquer host pode ter múltiplas aplicações que se comunicam através da rede. Cada uma destas aplicações irá se comunicar com uma ou mais aplicações em hosts remotos. É responsabilidade da camada de Transporte manter fluxos múltiplos de comunicação entre estas aplicações.</p><p><b>Segmentação de Dados</b></p><p>Como cada aplicação cria um fluxo de dados para ser enviado a uma aplicação remota, estes dados devem ser preparados para serem enviados através do meio em segmentos gerenciáveis. Os protocolos de camada de Transporte descrevem serviços que segmentam estes dados a partir da camada de Aplicação. Isto inclui o encapsulamento necessário em cada lado do segmento. Cada segmento de dados de aplicação requer a adição de cabeçalhos da camada de Transporte para indicar a qual comunicação ele está associado. </p><p><b>Reagrupamento de Segmentos</b></p><p>No host de destino, cada segmento de dados pode ser direcionado para a aplicação apropriada. Em adição a isso, estes segmentos de dados individuais também precisam ser reconstruídos em um fluxo completo de dados que seja útil para a camada de Aplicação. Os protocolos da camada de Transporte descrevem como a informação do cabeçalho da camada de Transporte é usada para reagrupar os segmentos de dados em fluxos a serem passados para a camada de Aplicação. </p><p><b>Identificação das Aplicações</b></p><p>Para passar os fluxos de dados para as aplicações apropriadas, a camada de Transporte deve identificar a aplicação de destino. Para realizar isso, a camada de Transporte designa à aplicação um identificador. Os protocolos TCP/IP chamam esse identificador de número de porta. A cada processo de software que precise acessar a rede é designado um número de porta único naquele host. Este número de porta é usado no cabeçalho da camada de transporte para indicar a qual aplicação aquele segmento de dado está associado. </p><p>A camada de Transporte é o link entre a camada de Aplicação e a camada inferior, que são responsáveis pela transmissão na rede. Esta camada aceita dados de diferentes conversações e os passa para as camadas inferiores como segmentos gerenciáveis que podem ser finalmente multiplexados no meio.</p><p>As aplicações não precisam saber dos detalhes operacionais da rede em uso. As aplicações geram dados que são enviados de uma aplicação a outra, sem considerar o tipo de host de destino, o tipo de meio sobre o qual o dado deve trafegar, o caminho tomado pelo dado, o <content-link target="cg8328321530" type="glossary">congestionamento</content-link> em um link, ou o tamanho da rede. </p><p>Adicionalmente, as camadas inferiores não estão a par de que existem múltiplas aplicações enviando dados na rede. Sua responsabilidade é entregar os dados ao dispositivo apropriado. A camada de transporte então organiza esses segmentos antes de entregá-los à aplicação apropriada.</p><p><b>As Necessidades de Dados Variam</b></p><p>Devido ao fato de diferentes aplicações terem diferentes necessidades, existem múltiplos protocolos da camada de Transporte. Para algumas aplicações, os segmentos devem chegar em uma sequência específica para serem processados com sucesso. Em alguns casos, todos os dados precisam ser recebidos por qualquer um deles para poder ser usado. Em outros casos, uma aplicação pode tolerar alguma perda de dados durante a transmissão através da rede. </p><p>Nas redes convergidas atuais, as aplicações com diferentes necessidades de transporte podem se comunicar na mesma rede. Os diferentes protocolos da camada de Transporte têm diferentes regras que permitem aos dispositivos lidar com essas necessidades diversas de dados.</p><p>Alguns protocolos fornecem apenas as funções básicas para entregar eficientemente os segmentos de dados entre as aplicações apropriadas. Estes tipos de protocolos são úteis para aplicações cujos dados são sensíveis a atrasos.</p><p>Outros protocolos da camada de Transporte descrevem processos que fornecem características adicionais, tais como assegurar a entrega confiável entre as aplicações. Embora estas funções adicionais proporcionem uma comunicação mais robusta na camada de Transporte entre as aplicações, elas geram uma sobrecarga adicional e fornecem maiores demandas sobre a rede.</p></content-text></page> <page type="OneColumn" id="tl0604010102"><content-media type="StaticGraphic" id="cm2907945546"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010100/tl0604010102/cm2907945546.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010100/tl0604010102/cm2907945546text.xml"/></content-media> <content-text><p><b>Separação de Múltiplas Comunicações</b></p><p>Considere um computador conectado a uma rede que está simultaneamente recebendo e enviando e-mails e mensagens instantâneas, exibindo websites e conduzindo uma chamada VoIP. Cada uma destas aplicações está enviando e recebendo dados através da rede ao mesmo tempo. No entanto, os dados da chamada telefônica não são direcionados ao navegador web, e o texto de uma mensagem instantânea não aparece em um e-mail.</p><p>Além disso, os usuários necessitam que um e-mail ou página web sejam completamente recebidos e apresentados para que a informação seja considerada útil. Atrasos leves são considerados aceitáveis para assegurar que a informação completa seja recebida e apresentada.</p><p>Em contraste, pequenas perdas ocasionada de partes de uma conversa telefônica pode ser considerada aceitável. Uma pessoa pode inferir a perda de áudio a partir do contexto da conversa ou pedir a outra pessoa para repetir o que foi dito. Isto é considerado preferível a atrasos que resultariam de pedido à rede para gerenciar e reenviar os segmentos perdidos. Neste exemplo, o usuário - não a rede - gerencia o reenvio ou substituição da informação perdida.</p></content-text></page> <page type="OneColumn" id="tl0604010103"><content-media type="StaticGraphic" id="cm6001954497"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010100/tl0604010103/cm6001954497.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010100/tl0604010103/cm6001954497text.xml"/></content-media> <content-text><p>Conforme foi explicado no capítulo anterior, o envio de alguns tipos de dados - um vídeo por exemplo - através da rede com um fluxo de comunicação completa pode impedir que outras comunicações ocorram ao mesmo tempo. Isso também dificulta a recuperação de erro e retransmissão de dados danificados.</p><p>A divisão de dados em partes pequenas, e o envio dessas partes a partir da origem, habilita muitas comunicações diferentes que podem estar intercaladas (multiplexadas) na mesma rede. </p><p>A segmentação de dados, de acordo com os protocolos de camada de Transporte, fornece os meios para enviar e receber dados quando se executam múltiplas aplicações concorrentemente em um computador. Sem segmentação, apenas uma aplicação, o vídeo em streaming, por exemplo, seria capaz de receber dados. Você não poderia receber e-mails, conversar em um programa de mensagens instantâneas, ou exibir páginas web enquanto estivesse exibindo o vídeo.</p><p>Na camada de Transporte, cada conjunto particular de segmentos que flui entre uma aplicação de origem e uma aplicação de destino é conhecido com uma conversação.</p><p>Para identificar cada segmento de dados, a camada de Transporte adiciona ao segmento um cabeçalho contendo dados binários. Este cabeçalho contém campos de bits. São os valores nesses campos que habilitam que diferentes protocolos de camada de Transporte realizem diferentes funções.</p></content-text></page></topic> <topic type="" id="tl0604010200">
<title><content-text>Controle das Conversações</content-text></title>
<page type="OneColumn" id="tl0604010201"><content-media type="StaticGraphic" id="cm6028553598"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010200/tl0604010201/cm6028553598.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010200/tl0604010201/cm6028553598text.xml"/></content-media> <content-text><p>As funções principais especificadas por todos os protocolos da camada de Transporte incluem:</p><p><b>Segmentação e Reagrupamento</b> - A maioria das redes tem uma limitação da quantidade de dados que podem ser incluídos em uma única PDU. A camada de Transporte divide os dados da aplicação em blocos de dados que estão em um tamanho apropriado. No destino, a camada de Transporte reagrupa os dados antes de enviá-los à aplicação ou serviço de destino.</p><p><b>Multiplexação de Conversação</b> - Podem haver muitas aplicações ou serviços sendo executados em cada host na rede. Cada uma destas aplicações ou serviços é designado a um endereço conhecido como uma porta para que a camada de Transporte possa determinar com qual aplicação ou serviço o dado é identificado.</p><p>Além de usar a informação contida nos cabeçalhos, para as funções básicas de segmentação e reagrupamento de dados, alguns protocolos da camada de Transporte fornecem:</p><ul><li> Conversações orientadas à conexão</li><li> Entrega Confiável</li><li> Reconstrução de dados ordenados</li><li> Controle de Fluxo</li></ul></content-text></page> <page type="OneColumn" id="tl0604010202"><content-media type="StaticGraphic" id="cm5472742017"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010200/tl0604010202/cm5472742017.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010200/tl0604010202/cm5472742017text.xml"/></content-media> <content-text><p><b>Estabelecimento de uma Sessão</b></p><p>A camada de Transporte pode fornecer essa orientação de conexão através da criação de sessões entre as aplicações. Estas conexões preparam as aplicações para se comunicarem entre si antes que qualquer dado seja transmitido.  Dentro destas sessões, os dados para uma comunicação entre as duas aplicações podem ser gerenciados de perto. </p><p><b>Entrega Confiável</b></p><p>Por muitas razões, é possível que um segmento de dados se torne corrompido, ou completamente perdido, quando ele é transmitido através da rede. A camada de Transporte pode assegurar que todorastreiem todas os segmentos atinjam seu destino tendo o dispositivo de origem para retransmitir qualquer dado que seja perdido.</p><p><b>Entrega na Mesma Ordem</b></p><p>Devido ao fato de que as redes podem fornecer múltiplas rotas que podem ter diferentes tempos de transmissão, os dados podem chegar na ordem errada. Através da numeração e sequenciamento dos segmentos, a camada de Transporte pode assegurar que esses segmentos sejam reagrupados na ordem apropriada. </p><p><b>Controle de Fluxo</b></p><p>Os hosts de rede têm recursos limitados, como memória e largura de banda. Quando a camada de Transporte está ciente de que esses recursos estão sobrecarregados, alguns protocolos podem solicitar que a aplicação de envio reduza a taxa de fluxo de dados. Isto é feito na camada de Transporte regulando a quantidade de dados que a origem transmite como um grupo. O controle de fluxo pode prevenir a perda de segmentos na rede e evitar a necessidade de retransmissão.</p><p>À medida que os protocolos forem discutidos neste capítulo, estes serviços serão explicados mais detalhadamente.</p></content-text></page></topic> <topic type="" id="tl0604010300">
<title><content-text>Suporte de Comunicação Confiável</content-text></title>
<page type="OneColumn" id="tl0604010301"><content-media type="StaticGraphic" id="cm2529899594"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010300/tl0604010301/cm2529899594.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010300/tl0604010301/cm2529899594text.xml"/></content-media> <content-text><p>Relembre que a função principal da camada de Transporte é gerenciar os dados da aplicação para as conversações entre os hosts. No entanto, diferentes aplicações têm diferentes necessidades para seus dados e, por isso, diferentes protocolos de Transporte têm sido desenvolvidos para satisfazer estas necessidades.</p><p>O protocolo da camada de Transporte pode implementar um método para assegurar a entrega confiável dos dados. Em termos de rede, confiabilidade significa assegurar que cada segmento de dado enviado pela origem chegue ao seu destino. Na camada de Transporte, as três operações básicas de confiabilidade são:</p><ul><li> rastreamento de dados transmitidos</li><li> confirmação de dados recebidos</li><li> retransmissão de quaisquer dados não confirmados</li></ul><p>Isto requer que os processos da camada de Transporte da origem rastreiem todos os segmentos de dados de cada conversação e retransmitam quaisquer dados que realmente não foram confirmados pelo destino. A camada de Transporte do host receptor também deve rastrear o dado à medida que ele é recebido e confirmar o recebimento do dado. </p><p>Estes processos de confiabilidade colocam uma sobrecarga adicional sobre os recursos de rede devido à confirmação, rastreamento e retransmissão. Para suportar estas operações de confiabilidade, mais <content-link target="cg8735611086" type="glossary">dados de controle</content-link> são trocados entre os hosts de envio e recepção. Esta informação de controle está contida no cabeçalho da Camada 4.</p><p>Isto cria um dilema entre o valor de confiabilidade e a carga que ela coloca sobre a rede. Os desenvolvedores de aplicações devem escolher que tipo de protocolo de transporte é apropriado com base nas necessidades de suas aplicações. Na camada de Transporte, existem protocolos que especificam métodos que sejam para entrega confiável, entrega garantida ou entrega de melhor esforço. No contexto de rede, a entrega de melhor esforço é referida como não confiável, porque não há confirmação de que o dado foi recebido no seu destino.</p><p><b>Determinação da Necessidade de Confiabilidade</b></p><p>As aplicações, tais como as bases de dados, páginas web e e-mail, necessitam de que todos os dados enviados cheguem ao destino em seu estado original, em ordem, para que os dados sejam úteis. Quaisquer perdas de dados podem causar uma comunicação corrompida que é incompleta ou ilegível. Portanto, estas aplicações são projetadas para usar um protocolo da camada de Transporte que implemente confiabilidade. A sobrecarga adicional de rede é considerada como uma necessidade para essas aplicações.</p><p>Outras aplicações são mais tolerantes com a perda de pequenas quantidades de dados. Por exemplo, se um ou dois segmentos de um fluxo de vídeo falharem ao chegar, isso cria apenas uma interrupção momentânea no fluxo. Isto pode parecer como uma distorção na imagem, mas pode até mesmo não ser notado pelo usuário. </p><p>A imposição de sobrecarga para assegurar a confiabilidade para essa aplicação pode reduzir a utilidade da mesma. A imagem do vídeo em streaming seria muito degradada se o dispositivo de destino tivesse de se responsabilizar pelos dados perdidos e pelo retardo no fluxo quando da espera por sua chegada. É melhor projetar uma boa imagem possível no tempo com os segmentos que chegam e abrir mão da confiabilidade. Se a confiabilidade é necessária por alguma razão, estas aplicações podem apresentar solicitações de verificação de erro e retransmissão.</p></content-text></page></topic> <topic type="" id="tl0604010400">
<title><content-text>TCP e UDP</content-text></title>
<page type="OneColumn" id="tl0604010401"><content-media type="StaticGraphic" id="cm3689212369"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010400/tl0604010401/cm3689212369.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010400/tl0604010401/cm3689212369text.xml"/></content-media> <content-text><p>Os dois protocolos da camada de Transporte mais comuns da pilha de protocolos TCP/IP são o Protocolo TCP e o Protocolo UDP. Ambos os protocolos gerenciam a comunicação de múltiplas aplicações. As diferenças entre os dois são as funções específicas que cada protocolo implementa. </p><p><b>Protocolo UDP (User Datagram Protocol)</b></p><p>O UDP é um protocolo simples e sem conexão, descrito na RFC 768. Ele tem a vantagem de fornecer uma entrega de dados de baixa sobrecarga. As segmentos de comunicação em UDP são chamados <content-link target="cg7597470738" type="glossary">datagramas</content-link>. Estes datagramas são enviados como o "melhor esforço" por este protocolo da camada de Transporte. </p><p>As aplicações que usam UDP incluem:</p><p>(DNS)</p><p>Vídeo em Streaming</p><p>Voz Sobre IP (VOIP)</p><p><b>Protocolo TCP</b></p><p>O TCP é um protocolo orientado à conexão, descrito na RFC 793. O TCP causa sobrecarga adicional para adicionar funções. As funções adicionais especificadas pelo TCP são as ditas entrega ordenada, entrega confiável e <content-link target="cg2965421688" type="glossary">controle de fluxo</content-link>. Cada segmento TCP tem 20 bytes de overhead no cabeçalho que encapsula o dado da camada de Aplicação, enquanto que o segmento UDP tem apenas 8 bytes. Veja a figura para uma comparação.</p><p>As aplicações que usam TCP são:</p><p>Navegadores web</p><p>E-mail</p><p>FTP</p></content-text></page></topic> <topic type="" id="tl0604010500">
<title><content-text>Endereçamento de Porta</content-text></title>
<page type="OneColumn" id="tl0604010501"><content-media type="StaticGraphic" id="cm9707646724"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010500/tl0604010501/cm9707646724.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010500/tl0604010501/cm9707646724text.xml"/></content-media> <content-text><p><b>Identificação de Conversações</b></p><p>Considere o exemplo anterior de um computador que simultaneamente recebe e envia e-mail, mensagens instantâneas, páginas web e chamada VOIP. </p><p>Os serviços baseados em TCP e UDP rastreiam as várias aplicações que estão se comunicando. Para diferenciar os segmentos e datagramas para cada aplicação, o TCP e o UDP têm campos de cabeçalho que podem identificar unicamente essas aplicações. Estes identificadores únicos são os números de porta.</p><p>No cabeçalho de cada segmento ou datagrama, há uma porta de origem e destino. O número da porta de origem é o número para essa comunicação associado à aplicação originada no host local. O número da porta de origem é o número para essa comunicação associada à aplicação originada no host local.</p><p>Os números de porta são designados de várias maneiras, dependendo se a mensagem é uma solicitação ou uma resposta. Embora os processos do servidor tenham números de porta estáticos designados a eles, os clientes escolhem dinamicamente um número de porta para cada conversação.</p><p>Quando uma aplicação cliente envia uma solicitação à aplicação servidor, a porta de destino contida no cabeçalho é o número da porta que é designado ao serviço daemon executado no host remoto. O software cliente deve conhecer qual número de porta está associado ao processo servidor no host remoto. Este número de porta de destino é configurado, seja através do padrão ou manualmente. Por exemplo, quando uma aplicação de navegador web faz uma solicitação a um servidor web, o navegador usa o TCP é número de porta 80, a menos que um outro seja especificado. Isso acontece porque a porta 80 TCP é a porta padrão designada a aplicações web. Muitas aplicações comuns têm designações de porta padrão. </p><p>A porta de origem em um cabeçalho de segmento ou datagrama de uma solicitação de cliente é gerada aleatoriamente. Contanto que ela não entre em conflito com outras portas em uso no sistema, o cliente pode escolher qualquer número de porta. Este número de porta age com um endereço de retorno para a aplicação que faz a solicitação. A camada de Transporte rastreia esta porta e a aplicação que iniciou a solicitação, de modo que quando uma resposta é retornada, ela pode ser encaminhada para a aplicação correta. O número de porta da aplicação solicitante é usado com o número de porta de destino na resposta que volta do servidor. </p><p>A combinação do número de porta da camada de Transporte e do endereço IP da camada de Rede designada ao host identifica exclusivamente um processo particular sendo executado em um dispositivo de host específico. Esta combinação é chamada de soquete. Ocasionalmente, você pode encontrar os termos número de porta e soquete sendo usados alternadamente. No contexto deste curso, o termo soquete se refere apenas à combinação única de endereço IP e número de porta. Um par de soquete, que consiste de endereços IP de origem e destino, é também único e identifica a conversação entre os dois hosts.</p><p>Por exemplo, uma solicitação de página HTTP sendo enviada a um servidor web (porta 80) sendo executado em um host com um endereço de IPv4 Camada 3 192.168.1.20 seria destinado ao soquete 192.168.1.20:80. </p><p>Se o navegador web que faz a solicitação à web está sendo executado no host 192.168.100.48 e o número Dinâmico de porta designado ao navegador web é 49152, o soquete para a página web seria 192.168.100.48:49152.</p></content-text></page> <page type="OneColumn" id="tl0604010502"><content-media type="InteractiveGraphicRollovers" id="cm4489228163"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010500/tl0604010502/cm4489228163.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010500/tl0604010502/cm4489228163text.xml"/></content-media> <content-text><p>A <content-link target="cg3738856075" type="glossary">Internet Assigned Numbers Authority (IANA)</content-link> designa números de porta. A IANA é um órgão de padrões responsável pela designação de vários padrões de endereçamento.</p><p>Existem diferentes tipos de números de portas:</p><p><b>Portas Conhecidas</b> (Números 0 a 1023) - Esses números estão reservados para serviços e aplicações. Eles são comumente usados para aplicações como o HTTP (servidor web) POP3/SMTP (servidor de e-mail) e Telnet. Através da definição destas <content-link target="cg2891500490" type="glossary">portas conhecidas</content-link> para aplicações de servidor, aplicações de clientes podem ser programados para solicitar uma conexão com essa porta específica e seu serviço associado.</p><p><b>Portas Registradas </b> (Números 1024 a 49151) - Estes números de portas são designados para processos ou aplicações de usuário. Estes processos são principalmente aplicações individuais que um usuário escolheu para instalar em vez de aplicações comuns que receberiam uma Porta Conhecida. Quando não usadas para um recurso de servidor, estas portas também podem ser dinamicamente selecionadas por um cliente como sua porta de origem.</p><p><b>Portas Dinâmicas ou Privadas</b> (Números 49152 a 65535) - Elas são geralmente designadas dinamicamente a aplicações de cliente quando se inicia uma conexão. Não é muito comum um cliente se conectar a um serviço usando uma Porta Dinâmica ou Privada (embora alguns programas de compartilhamento de arquivos peer-to-peer o façam). </p><p><b>Utilização do TCP e do UDP</b></p><p>Algumas aplicações podem usar tanto TCP como UDP. Por exemplo, o baixo overhead (sobrecarga) do UDP habilita ao DNS servir a muitas solicitações de clientes muito rapidamente. As vezes, no entanto, o envio da informação solicitada pode exigir a confiabilidade do TCP. Neste caso, o número 53 de porta conhecida é usado por ambos os protocolos com este serviço.</p><p><b>Links</b></p><p>Uma lista atual de números de porta pode ser encontrada em <content-link target="http://www.iana.org/assignments/port-numbers" type="external">http://www.iana.org/assignments/port-numbers</content-link>.</p></content-text></page> <page type="OneColumn" id="tl0604010503"><content-media type="InteractiveGraphicRollovers" id="cm6760618296"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010500/tl0604010503/cm6760618296.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010500/tl0604010503/cm6760618296text.xml"/></content-media> <content-text><p>As vezes é necessário conhecer quais conexões TCP ativas estão abertas e sendo executadas em um host de rede. O <span class="cmd"><b>Netstat</b></span> é um utilitário de rede importante que pode ser usado para verificar essas conexões. O <span class="cmd"><b>Netstat</b></span> lista o protocolo em uso, o endereço local e o número de porta, o endereço externo, o número de porta e o estado da conexão. </p><p>Conexões TCP inexplicáveis podem ser uma grande ameaça de segurança. Isto acontece porque elas podem indicar que algo ou alguém está conectado ao host local. Adicionalmente, as conexões TCP desnecessárias podem consumir recursos valiosos do sistema, reduzindo a velocidade de desempenho do host. O <span class="cmd"><b>Netstat</b></span> deve ser usado para examinar as conexões abertas em um host quando o desempenho parecer comprometido. </p><p>Muitas opções úteis estão disponíveis para o comando <span class="cmd"><b>netstat</b></span>.</p></content-text></page></topic> <topic type="" id="tl0604010600">
<title><content-text>Segmentação e Reagrupamento - Dividir e Conquistar</content-text></title>
<page type="OneColumn" id="tl0604010601"><content-media type="StaticGraphic" id="cm5820324751"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010600/tl0604010601/cm5820324751.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604010000/tl0604010600/tl0604010601/cm5820324751text.xml"/></content-media> <content-text><p>O capítulo anterior explicou como as PDUs são construídas para passar os dados de uma aplicação para os vários protocolos para criar uma PDU que seja então transmitida no meio. No host de destino, este processo é revertido até que os dados possam ser passados até a aplicação.</p><p>Algumas aplicações transmitem grandes quantidades de dados - em alguns casos, muitos gigabytes. Seria impraticável enviar todos estes dados em um segmento muito grande. Nenhum outro tráfego de rede poderia ser transmitido enquanto estes dados estivessem sendo enviados. Um segmento muito grande de dados pode levar minutos ou mesmo horas para ser enviado. Além disso, se houvesse algum erro, o arquivo inteiro seria perdido ou reenviado. Dispositivos de rede não teriam buffers de memória grandes o suficiente para armazenar estes dados enquanto eles fossem transmitidos ou recebidos. O limite varia dependendo da tecnologia de rede e do meio físico específico que está sendo usado.</p><p><b>Dividir os dados da aplicação em segmentos assegura que os dados sejam transmitidos dentro dos limites do meio e que os dados de diferentes aplicações possam ser multiplexadas no meio.</b></p><p><b>O TCP e o UDP Lidam com a Segmentação de Maneira Diferente.</b></p><p>No TCP, cada cabeçalho de segmento contém um número sequencial. Este número sequencial confere as funções da camada de Transporte no host de destino para reagrupar segmentos na ordem em que eles foram transmitidos. Isso assegura que as aplicações de destino tenham os dados na forma exata pretendida pelo remetente.</p><p>Embora os serviços que usam UDP também rastreiem as conversações entre as aplicações, eles não estão preocupados com a ordem que a informação foi transmitida, ou na manutenção de uma conexão. Não existe número sequencial no cabeçalho UDP. O UDP é um esquema mais simples e gera menos overhead do que o TCP, resultando em uma transferência mais rápida de dados. </p><p>A informação pode chegar em ordem diferente da qual ela foi transmitida porque diferentes pacotes podem tomar diferentes caminhos através da rede. Uma aplicação que usa o UDP precisa tolerar o fato de que os dados podem não chegar na ordem em que foram enviados.</p></content-text></page> <page type="OneColumn" id="tl0604010602"><content-media type="ActivityPKA" id="cm7581778394"><title><content-text></content-text></title><media ref="tl0604000000/tl0604010000/tl0604010600/tl0604010602/cm7581778394/" mime="application/packettracer" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604010000/tl0604010600/tl0604010602/cm7581778394/icontext.xml"/></content-media> <content-text><p>Nesta atividade, você "olhará dentro" de pacotes para ver como o DNS e o HTTP usam os números de porta. </p><p><b>Clique no ícone do Packet Tracer para iniciar a atividade.</b></p></content-text></page></topic></section> <section type="" id="tl0604020000">
<title><content-text>O Protocolo TCP - Comunicando com Confiabilidade</content-text></title>
<topic type="" id="tl0604020100">
<title><content-text>TCP - Tornando as Conversações Confiáveis</content-text></title>
<page type="OneColumn" id="tl0604020101"><content-media type="InteractiveGraphicRollovers" id="cm7307395386"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020100/tl0604020101/cm7307395386.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020100/tl0604020101/cm7307395386text.xml"/></content-media> <content-text><p><b>A distinção principal entre o TCP e o UDP está na confiabilidade. </b>A confiabilidade da comunicação TCP é realizada com o uso de sessões orientadas à conexão.  Antes que um host usando o TCP envie dados para outro host, a camada de Transporte inicia um processo para criar uma conexão com o destino. Esta conexão habilita o rastreamento de uma sessão, ou um fluxo de comunicação entre os hosts. Este processo assegura que cada host está ciente e preparado para a comunicação. Uma conversação TCP completa exige o estabelecimento de uma sessão entre os hosts em ambas as direções.</p><p>Após uma sessão ter sido estabelecida, o destino envia confirmações para a origem para os segmentos que ele recebe. Estas confirmações formam a base da confiabilidade dentro de uma sessão TCP. À medida que a origem recebe uma confirmação, ela sabe que os dados foram entregues com sucesso e pode parar o rastreamento daqueles dados. Se a origem não recebe uma confirmação dentro de um período pré-determinado de tempo, ela retransmite aqueles dados para o destino. </p><p>Parte do overhead adicional do uso do TCP é o tráfego de rede gerado por confirmações e retransmissões. O estabelecimento de sessões cria um overhead na forma de segmentos adicionais sendo trocados. Há também um overhead adicional nos hosts individuais criado pela necessidade de rastrear quais segmentos estão esperando pela confirmação e pelo processo de retransmissão.</p><p>Esta confiabilidade é alcançada tendo campos no segmento TCP, cada um com uma função específica, conforme mostrado na figura. Estes campos serão discutidos mais tarde nesta seção.</p></content-text></page></topic> <topic type="" id="tl0604020200">
<title><content-text>Processos TCP em Servidores</content-text></title>
<page type="OneColumn" id="tl0604020201"><content-media type="InteractiveGraphicRollovers" id="cm1111794604"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020200/tl0604020201/cm1111794604.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020200/tl0604020201/cm1111794604text.xml"/></content-media> <content-text><p>Conforme discutido anteriormente neste capítulo, os processos de aplicações são executados nos servidores. Estes processos esperam até que um cliente inicie a comunicação com uma solicitação de informação ou outros serviços.</p><p>Cada processo de aplicação sendo executado no servidor é configurado para usar um número de porta, seja no modo padrão ou manualmente através de um administrador do sistema. <b>Um servidor individual não pode ter dois serviços designados ao mesmo número de porta dentro dos mesmos serviços da camada de Transporte. </b>Um host executando uma aplicação de servidor web e uma aplicação de transferência de arquivo não pode ter ambos configurados para usar a mesma porta (por exemplo, a porta TCP 8080). Quando uma aplicação de servidor ativo é designada a uma porta específica, essa porta é considerada como estando "aberta" no servidor. Isto significa que a camada de Transporte aceita e processa segmentos endereçados àquela porta. Qualquer solicitação de cliente que chega endereçada ao soquete correto é aceita e os dados são transmitidos à aplicação do servidor. Podem haver muitas portas simultâneas abertas em um servidor, uma para cada aplicação de servidor ativo. É comum para um servidor fornecer mais de um serviço, como um servidor web e um servidor FTP, ao mesmo tempo.</p><p>Uma maneira de melhorar a segurança em um servidor é restringir o acesso de servidor a apenas essas portas associadas com os serviços e as aplicações que devem ser acessíveis para solicitantes autorizados. </p><p>A figura mostra a alocação típica de portas de origem e destino em operações cliente/servidor TCP.</p></content-text></page></topic> <topic type="" id="tl0604020300">
<title><content-text>Estabelecimento e Término de conexões TCP</content-text></title>
<page type="OneColumn" id="tl0604020301"><content-media type="InteractiveGraphicRollovers" id="cm5977147278"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020300/tl0604020301/cm5977147278.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020300/tl0604020301/cm5977147278text.xml"/></content-media> <content-text><p>Quando dois hosts se comunicam usando o TCP, uma conexão é estabelecida antes que os dados possam ser trocados. Depois da comunicação ter sido completada, as sessões são fechadas e a conexão é encerrada. Os mecanismos de conexão e sessão habilitam a função de confiabilidade do TCP.</p><p><b>Veja a figura para saber as etapas para estabelecer e terminar uma conexão TCP.</b></p><p>O host rastreia cada segmento de dados dentro de uma sessão e troca informação sobre qual dado é recebido por cada host usando a informação no cabeçalho TCP. </p><p>Cada conexão representa dois fluxos de comunicação, ou sessões. Para estabelecer uma conexão, os hosts realizam um <content-link target="cg2603496200" type="glossary">handshake triplo</content-link>. Bits de controle no cabeçaçho TCP indicam o progresso e o status da conexão. O handshake triplo:</p><ul><li> Estabelece que o dispositivo de destino está presente na rede</li><li> Verifica se o dispositivo de destino tem um serviço ativo e está aceitando solicitações no número de porta de destino que o cliente pretende usar para a sessão.</li><li> Informa o dispositivo de destino que o cliente de origem pretende estabelecer uma sessão de comunicação nessa número de porta</li></ul><p>Nas conexões TCP, o host que serve como um cliente inicia a sessão para o servidor. Os três passos no estabelecimento da conexão TCP são:</p><p>1. O cliente iniciador envia um segmento contendo um valor sequencial inicial, que serve como uma solicitação ao servidor para começar uma sessão de comunicações.</p><p>2. O servidor responde com um segmento contendo um valor de confirmação igual ao valor sequencial recebido mais 1, mais seu próprio valor sequencial de sincronização. O valor é maior do que o número sequencial porque o ACK é sempre o próximo Byte ou Octeto esperado. Este valor de confirmação habilita o cliente a submeter à resposta de volta ao segmento original que ele enviou ao servidor. </p><p>3. O cliente iniciador responde com um valor de confirmação igual ao valor sequencial que ele recebeu mais um. Isso completa o processo de estabelecimento da conexão.</p><p>Para entender o processo do handshake triplo, é importante examinar os vários valores que os dois hosts trocam. Dentro do cabeçalho de segmento TCP, existem seis campos de 1 bit que contêm a informação de controle usada para gerenciar os processos TCP. Esses campos são: </p><p><b>URG </b>- Indicador urgente de campo significativo</p><p><b>ACK </b>- Campo significativo de confirmação</p><p><b>PSH </b>- função Push</p><p><b>RST </b>- Restabelecer a conexão</p><p><b>SYN </b>- Sincronizar <content-link target="cg4695291891" type="glossary">números de sequência</content-link></p><p><b>FIN </b>- Não há mais dados do remetente</p><p>Estes campos são referidos como flags (flags), porque o valor de um desses campos é apenas 1 bit e, portanto, tem apenas dois valores: 1 ou 0. Quando um valor de bit é definido como 1, ele indica que a informação de controle está contida no segmento.</p><p>Com o uso de um processo de quatro etapas, as flags são trocadas para encerrar uma conexão TCP.</p></content-text></page></topic> <topic type="" id="tl0604020400">
<title><content-text>Handshake Triplo TCP</content-text></title>
<page type="OneColumn" id="tl0604020401"><content-media type="StaticGraphic" id="cm3626205190"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020400/tl0604020401/cm3626205190.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020400/tl0604020401/cm3626205190text.xml"/></content-media> <content-text><p>Usando as entradas Wireshark, você pode examinar a operação do handshake triplo TCP:</p><p><b>Etapa 1</b></p><p>Um cliente TCP inicia o handshake triplo enviando um segmento com a flag de controle SYN (número sequencial de sincronia) definido, indicando um valor inicial no campo do número de sequência no cabeçalho. Este valor inicial para o número de sequência, conhecido como o Número de Sequência Inicial (ISN), é escolhido aleatoriamente e é usado para iniciar o rastreamento do fluxo de dados do cliente para o servidor para esta sessão. O ISN no cabeçalho de cada segmento é aumentado em um para cada byte de dados enviados do cliente para o servidor à medida que a conversação de dados continua.</p><p>Conforme mostrado na figura, a saída de um analisador de protocolo mostra a flag de controle SYN e o número de sequência relativo. </p><p>A flag de controle SYN é definida e o número de sequência relativo é 0. Embora o analisador de protocolo no gráfico indique os valores relativos para os números de sequências e de confirmação, os valores verdadeiros são números binários de 32 bits. Nós podemos determinar os números reais enviados nos cabeçalhos do segmento examinando a tela de Pacote de Bytes. Aqui você pode ver os quatro bytes representados em <content-link target="cg2034619012" type="glossary">hexadecimal</content-link>.</p></content-text></page> <page type="OneColumn" id="tl0604020402"><content-media type="StaticGraphic" id="cm3903872438"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020400/tl0604020402/cm3903872438.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020400/tl0604020402/cm3903872438text.xml"/></content-media> <content-text><p><b>Etapa 2</b></p><p>O servidor TCP precisa confirmar o recebimento do segmento SYN do cliente para estabelecer a sessão do cliente para o servidor. Para fazer isso, o servidor envia um segmento de volta para o cliente com a flag ACK indicando que o número de Confirmação é significativo. Com esta flag indicada no segmento, o cliente confirma isto como uma confirmação de que o servidor recebeu o SYN do cliente TCP. </p><p>O valor do campo de número de <content-link target="cg4350071199" type="glossary">confirmação</content-link> é igual ao número de sequência inicial mais 1. Isto estabelece uma sessão do cliente para o servidor. A flag ACK permanecerá definida para o equilíbrio da sessão. Relembre que a conversação entre o cliente e o servidor é na verdade duas sessões unidirecionais, uma do cliente para o servidor, e outra do servidor para o cliente. Nesta segunda etapa do handshake triplo, o servidor precisa iniciar a resposta do servidor para o cliente. Para iniciar esta sessão, o servidor usa a flag SYN da mesma maneira que o cliente o fez. Ele define a flag de controle SYN no cabeçalho para estabelecer a sessão do servidor para o cliente. A flag SYN indica que o valor inicial do campo de número de sequência está no cabeçalho. Este valor será usado para rastrear o fluxo de dados nesta sessão do servidor de volta para o cliente.</p><p>Conforme mostrado na figura, a saída do analisador de protocolo mostra que as flags de controle ACK e SYN estão definidas e os números de sequência relativo e de confirmação são mostrados.</p></content-text></page> <page type="OneColumn" id="tl0604020403"><content-media type="StaticGraphic" id="cm9650257006"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020400/tl0604020403/cm9650257006.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020400/tl0604020403/cm9650257006text.xml"/></content-media> <content-text><p><b>Etapa 3</b></p><p>Finalmente, o cliente TCP responde com um segmento contendo um ACK que é a resposta para o TCP SYN enviado pelo servidor. Não há dado de usuário neste segmento. O valor do campo de número de confirmação contém um 1 a mais do que o número de sequência inicial recebido do servidor. Já que ambas as sessões estão estabelecidas entre cliente e servidor, todos os segmentos adicionais trocados nesta comunicação terão uma flag ACK definida.</p><p>Conforme mostrado na figura, a saída do analisador de protocolo mostra a flag de controle ACK definida e os números de confirmação são mostrados. </p><p>A segurança pode ser adicionada à rede de dados por:</p><ul><li> Negação de estabelecimento de sessões TCP</li><li> Apenas permitindo sessões que sejam estabelecidas para serviços específicos</li><li> Apenas permitindo tráfego como parte de sessões já estabelecidas</li></ul><p>Esta segurança pode ser implementada para todas as sessões TCP ou apenas para as sessões selecionadas.</p></content-text></page></topic> <topic type="" id="tl0604020500">
<title><content-text>Encerramento de Sessão TCP</content-text></title>
<page type="OneColumn" id="tl0604020501"><content-media type="StaticGraphic" id="cm5895607750"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020500/tl0604020501/cm5895607750.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604020000/tl0604020500/tl0604020501/cm5895607750text.xml"/></content-media> <content-text><p>Para fechar uma conexão, a <content-link target="cg2042422236" type="glossary"> flag de fim de comunicação FIN (Finish)</content-link> no cabeçalho do segmento precisa ser definida. Para terminar cada sessão TCP unidirecional, um handshake duplo é usado, consistindo de um segmento FIN e um segmento ACK. Portanto, para terminar uma conversação única suportada pelo TCP, quatro trocas são necessárias para finalizar ambas as sessões. <b>Nota</b>: Nesta explicação, os termos cliente e servidor são usados nesta descrição com uma referência visando a simplicidade, mas o processo de encerramento pode ser iniciado por qualquer um dos dois hosts que completarem a sessão:</p><p>1. Quando o cliente não tem mais dados para enviar no fluxo, ele envia um segmento com uma flag FIN definida.</p><p>2. O servidor envia uma ACK para confirmar o recebimento do FIN para encerrar a sessão do cliente para o servidor.</p><p>3. O servidor envia um FIN para o cliente, para encerrar a sessão do servidor para o cliente.</p><p>4. O cliente responde com um ACK para confirmar o FIN do servidor.</p><p>Quando o cliente final de uma sessão não tem mais dados para transferir, ele define a flag FIN no cabeçalho de um segmento. A seguir, o servidor irá enviar um segmento normal contendo dados com a flag ACK definida usando o número de confirmação, confirmando que todos os bytes de dados foram recebidos. Quando todos os segmentos tiverem sido confirmados, a sessão é fechada.</p><p>A sessão na outra direção é fechada usando o mesmo processo. O receptor indica que não há mais dados para enviar definindo uma flag FIN no cabeçalho de um segmento enviado à origem. Uma confirmação de retorno confirma que todos os bytes de dados foram recebidos e que a sessão está, por sua vez, fechada.</p><p>Conforme mostrado na figura, as flags de controle FIN e ACK são definidas no cabeçalho do segmento, fechando com isso a sessão HTTP.</p><p>É possível encerrar a conexão através de um handshake triplo. Quando o cliente não tem mais dados para enviar, ele envia um FIN ao servidor. Se o servidor também não tem mais dados para enviar, ele pode responder com ambas as flags FIN e ACK definidas, combinando duas etapas em uma. O cliente responde com um ACK.</p></content-text></page> <page type="OneColumn" id="tl0604020502"><content-media type="ActivityPKA" id="cm2215239984"><title><content-text></content-text></title><media ref="tl0604000000/tl0604020000/tl0604020500/tl0604020502/cm2215239984/" mime="application/packettracer" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604020000/tl0604020500/tl0604020502/cm2215239984/icontext.xml"/></content-media> <content-text><p>Nesta atividade, você irá estudar o handshake triplo TCP para estabelecimento de sessão e o processo TCP para encerramento. Muitos protocolos de aplicações usam TCP, e visualizar os processos de estabelecimento e encerramento de sessão com o Packet Tracer aprofundará o seu entendimento.</p><p><b>Clique no ícone do Packet Tracer para iniciar a atividade.</b></p></content-text></page></topic></section> <section type="" id="tl0604030000">
<title><content-text>Gerenciamento de Sessões TCP</content-text></title>
<topic type="" id="tl0604030100">
<title><content-text>Reagrupamento de Segmentos TCP</content-text></title>
<page type="OneColumn" id="tl0604030101"><content-media type="StaticGraphic" id="cm1839101137"><title><content-text></content-text></title><media ref="tl0604000000/tl0604030000/tl0604030100/tl0604030101/cm1839101137.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604030000/tl0604030100/tl0604030101/cm1839101137text.xml"/></content-media> <content-text><p><b>Refazendo o Sequenciamento de Segmentos na Ordem Transmitida</b></p><p>Quando os serviços enviam dados usando o TCP, os segmentos podem chegar no seu destino fora de ordem. Para a mensagem original ser entendida pelo receptor, os dados desses segmentos são reagrupados na sua ordem original. Os números de sequência são designados no cabeçalho de cada pacote para alcançar essa meta. </p><p>Durante a instalação de uma sessão, um número de sequência inicial (ISN) é definido. Este número de sequência inicial representa o valor de partida para os bytes para esta sessão que será transmitida para a aplicação receptora. À medida que os dados são transmitidos durante a sessão, o número de sequência é incrementado pelo número de bytes que foram transmitidos. Este rastreamento de bytes de dados habilita a cada segmento ser identificado e reconhecido de forma única. Segmentos perdidos podem ser identificados. </p><p>Os números de sequência do segmento habilitam a confiabilidade, indicando como reagrupar e reordenar segmentos recebidos, conforme mostrado na figura. </p><p>O processo TCP do receptor coloca os dados de um segmento em um buffer. Os segmentos são colocados na ordem de número de sequência apropriada e passados para a camada de Aplicação quando reagrupados. Quaisquer segmentos que cheguem com números de sequência não contíguos são retidos para processamento posterior. Então, quando os segmentos com os bytes perdidos chegam, esses segmentos são processados.</p></content-text></page></topic> <topic type="" id="tl0604030200">
<title><content-text>Confirmação TCP com Janelamento</content-text></title>
<page type="OneColumn" id="tl0604030201"><content-media type="StaticGraphic" id="cm8066369059"><title><content-text></content-text></title><media ref="tl0604000000/tl0604030000/tl0604030200/tl0604030201/cm8066369059.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604030000/tl0604030200/tl0604030201/cm8066369059text.xml"/></content-media> <content-text><p><b>Confirmação de Recebimento de Segmentos</b></p><p>Uma das funções do TCP é assegurar que cada segmento atinja o seu destino. Os serviços TCP no host de destino confirmam os dados que ele recebeu para a aplicação de origem. </p><p>O número de sequência do cabeçalho do segmento e o número de confirmação são usados juntamente para confirmar o recebimento dos bytes de dados contidos nos segmentos. O número de sequência é o número relativo de bytes que foram transmitidos nessa sessão mais 1 (que é o número do primeiro byte de dado no segmento corrente). O TCP usa o número de confirmação em segmentos enviados de volta à origem para indicar o próximo byte que o receptor espera receber nessa sessão. Isto é chamado de <i>confirmação esperada</i>. </p><p>A origem é informada de que o destino recebeu todos os bytes neste fluxo de dados até, mas não incluindo, o byte indicado pelo número de confirmação. Espera-se que o host de envio envie um segmento que use um número de sequência que é igual ao número de confirmação. </p><p>Lembre-se, cada conexão é na verdade composta por duas sessões unidirecionais. Os números de sequência e de confirmação estão sendo trocados em ambas as direções.</p><p>No exemplo da figura, o host da esquerda está enviando dados para o host da direita. Ele envia um segmento contendo 10 bytes de dados para essa sessão e um número de sequência igual a 1 no cabeçalho. </p><p>O host receptor da direita recebe o segmento na Camada 4 e determina que o número de sequência é 1 e que ele tem 10 bytes de dados. O host então envia um segmento de volta ao host da esquerda para confirmar o recebimento deste dado. Neste segmento, o host define o número de confirmação em 11 para indicar que o próximo byte de dados que ele espera receber nessa sessão é o byte número 11.</p><p>Quando o host de envio da esquerda recebe essa confirmação, ele pode agora enviar o próximo segmento contendo dados para essa sessão iniciando com o byte número 11.</p><p>Examinando esse exemplo, se o host de envio tiver que esperar pela confirmação de recebimento de cada 10 bytes, a rede teria muito overhead. Para reduzir o overhead dessas confirmações, múltiplos segmentos de dados podem ser enviados e confirmados com uma única mensagem TCP na direção oposta. Este confirmação contém um número de confirmação baseado no número total de bytes recebidos na sessão. </p><p>Por exemplo, começando com um número de sequência de 2000, se 10 segmentos de 1000 bytes cada fossem recebidos, o número de confirmação 12001 seria retornado à origem. </p><p>A quantidade de dados que a origem pode transmitir antes que uma confirmação seja recebida é chamada de <content-link target="cg2323423714" type="glossary">tamanho da janela</content-link>. O Tamanho de Janela é um campo no cabeçalho TCP que habilita o gerenciamento de dados perdidos e controle de fluxo.</p></content-text></page></topic> <topic type="" id="tl0604030300">
<title><content-text>Retransmissão TCP</content-text></title>
<page type="OneColumn" id="tl0604030301"><content-media type="AnimationPartialScreen" id="cm1108087151"><title><content-text></content-text></title><media ref="tl0604000000/tl0604030000/tl0604030300/tl0604030301/cm1108087151.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604030000/tl0604030300/tl0604030301/cm1108087151text.xml"/></content-media> <content-text><p><b>Lidando com a Perda de Segmento</b></p><p>Não importa quanto uma rede seja bem projetada, a perda de dados ocorrerá ocasionalmente. Portanto, o TCP fornece métodos para gerenciar essas perdas de segmentos. Entre estes métodos há um mecanismo que retransmite segmentos com dados não confirmados.</p><p>Um serviço de host de destino usando TCP geralmente reconhece os dados apenas para bytes sequenciais contíguos. Se estiver faltando um ou mais segementos, apenas os dados nos segmentos que completam o fluxo serão confirmados. </p><p>Por exemplo, se os segmentos com números de sequência de 1500 a 3000 e de 3400 a 3500 fossem recebidos, o número de confirmação seria 3001. Isto porque existem segmentos com os números de sequência de 3001 a 3399 que não foram recebidos.</p><p>Quando o TCP no host de origem não recebeu uma confirmação depois de um período pré-determinado de tempo, ele voltará ao último número de confirmação que recebeu e retransmitirá os dados a partir daquele ponto para frente.</p><p>O processo de retransmissão não é especificado pela RFC, mas é deixado para a implementação específica do TCP. </p><p>Para uma implementação de TCP típica, um host pode transmitir um segmento, colocar uma cópia do segmento numa fila de retransmissão e iniciar uma contagem. Quando a confirmação do dado é recebida, o segmento é deletado da fila. Se a confirmação não for recebida antes da contagem expirar, o segmento é retransmitido. </p><p>A animação demonstra a retransmissão de segmentos perdidos.</p><p>Os hosts atualmente podem também empregar um atributo adicional chamado de <i>Confirmações Seletivas</i>. Se ambos os hosts suportam Confirmações Seletivas, é possível para o destino confirmar bytes em segmentos não contíguos e o host precisará apenas retransmitir os dados perdidos.</p></content-text></page></topic> <topic type="" id="tl0604030400">
<title><content-text>Controle de Congestionamento TCP - Minimizando a Perda de Segmentos</content-text></title>
<page type="OneColumn" id="tl0604030401"><content-media type="StaticGraphic" id="cm3515319049"><title><content-text></content-text></title><media ref="tl0604000000/tl0604030000/tl0604030400/tl0604030401/cm3515319049.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604030000/tl0604030400/tl0604030401/cm3515319049text.xml"/></content-media> <content-text><p><b>Controle de Fluxo</b></p><p>O TCP também fornece mecanismos para o controle de fluxo. O controle de fluxo ajuda na confiabilidade de transmissões TCP através do ajuste da taxa de fluxo de dados efetiva entre os dois serviços na sessão. Quando a origem é informada de que uma quantidade especificada de dados nos segmentos é recebida, ela pode continuar a enviar mais dados para essa sessão.</p><p>O campo Tamanho de Janela no cabeçalho TCP especifica a quantidade de dados que podem ser transmitidos antes que uma confirmação precise ser recebida. O tamanho de janela inicial é determinado durante a inicialização da sessão através do handshake triplo.</p><p>O mecanismo de feedback do TCP ajusta a taxa efetiva de transmissão de dados até o fluxo máximo que a rede e o dispositivo de destino podem suportar sem perda. O TCP tenta gerenciar a taxa de transmissão de modo que todos os dados sejam recebidos e as retransmissões sejam minimizadas. </p><p>Veja a figura para uma representação simplificada do tamanho de janela e confirmações. Neste exemplo, o tamanho de janela inicial para uma sessão TCP representada é definido em 3000 bytes. Quando o remetente tiver transmitido 3000 bytes, ele espera por uma confirmação destes bytes antes de transmitir mais segmentos nesta sessão. </p><p>Quando o remetente tiver recebido esta confirmação do receptor, o remetente poderá transmitir mais 3000 bytes. </p><p>Durante o atraso no recebimento de uma confirmação, o remetente não enviará quaisquer segmentos adicionais para essa sessão. Em períodos em que a rede está congestionada ou os recursos do host de recebimento estão extenuados, o atraso pode aumentar. À medida que este atraso aumenta, a taxa de transmissão efetiva dos dados para esta sessão diminui. A diminuição da velocidade na taxa de dados ajuda a reduzir a contenção de recursos.</p></content-text></page> <page type="OneColumn" id="tl0604030402"><content-media type="StaticGraphic" id="cm7520409457"><title><content-text></content-text></title><media ref="tl0604000000/tl0604030000/tl0604030400/tl0604030402/cm7520409457.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604030000/tl0604030400/tl0604030402/cm7520409457text.xml"/></content-media> <content-text><p><b>Redução do Tamanho de Janela</b></p><p>Um outro modo de controlar o fluxo de dados é usar tamanhos de janela dinâmicos. Quando os recursos da rede são restringidos, o TCP pode reduzir o tamanho de janela para exigir que os segmentos recebidos sejam confirmados mais frequentemente. Isto diminui efetivamente a velocidade da taxa de transmissão porque a origem espera que os dados sejam confirmados mais frequentemente.</p><p>O host de recebimento envia o valor do tamanho de janela ao remetente para indicar o número de bytes que ele está preparado para receber como parte desta sessão. Se o destino precisar diminuir a velocidade da taxa de comunicação por causa de memória de buffer limitada, ele pode enviar um valor de tamanho de janela pequeno para a origem como parte de uma confirmação.</p><p>Conforme mostrado na figura, se um host de recebimento tem um congestionamento, ele pode responder ao host de envio com um segmento com tamanho de janela reduzido. Neste gráfico, há uma perda de um dos segmentos. O receptor mudou o campo da janela no cabeçalho TCP de segmentos retornados nesta conversação de 3000 para 1500. Isto levou o remetente a reduzir o tamanho de janela para 1500.</p><p>Após períodos de transmissão com nenhuma perda de dados ou restrição de recursos, o receptor começará a aumentar o campo da janela. Isto reduz a sobrecarga na rede porque poucas confirmações precisam ser enviadas. O tamanho de janela continuará a aumentar até que haja perda de dados, o que levará à diminuição novamente.</p><p>Este aumento e diminuição dinâmico no tamanho de janela é um processo contínuo no TCP, que determina o tamanho de janela adequado para cada sessão TCP. Em redes altamente eficientes, os tamanhos de janela podem se tornar muito grandes porque os dados não estão sendo perdidos. Nas redes em que a infra-estrutura subjacente é pressionada, o tamanho de janela provavelmente permanecerá pequeno.</p><p>Links</p><p>Detalhes das várias características de gerenciamento de congestionamento do TCP podem ser encontrados na RFC 2581.</p><p><content-link target="http://www.ietf.org/rfc/rfc2581.txt" type="external">http://www.ietf.org/rfc/rfc2581.txt</content-link></p></content-text></page></topic></section> <section type="" id="tl0604040000">
<title><content-text>O Protocolo UDP - Comunicação com Baixo Overhead</content-text></title>
<topic type="" id="tl0604040100">
<title><content-text>UDP - Baixo Overhead versus Confiabilidade</content-text></title>
<page type="OneColumn" id="tl0604040101"><content-media type="StaticGraphic" id="cm9624919054"><title><content-text></content-text></title><media ref="tl0604000000/tl0604040000/tl0604040100/tl0604040101/cm9624919054.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604040000/tl0604040100/tl0604040101/cm9624919054text.xml"/></content-media> <content-text><p>O UDP é um protocolo simples que fornece as funções básicas da camada de Transporte. Ele possui overhead muito mais baixo do que o TCP, já que não é orientado à conexão e não fornece mecanismos de retransmissão, sequenciamento e controle de fluxo sofisticados.</p><p>Isto não significa que as aplicações que usam UDP sejam sempre não confiáveis. Isto simplesmente significa que estas funções não são fornecidas pelo protocolo da camada de Transporte e devem ser implementadas em outros locais se houver necessidade.</p><p>Embora a quantidade total de tráfego UDP encontrada em uma rede típica geralmente não seja baixo, os principais protocolos da camada de Aplicação que usam UDP incluem:</p><ul><li> Domain Name System (DNS)</li><li> Simple Network Management Protocol (SNMP)</li><li> Protocolo de Configuração Dinâmica de Host (DHCP)</li><li> Routing Information Protocol (RIP)</li><li> Trivial File Transfer Protocol (TFTP)</li><li> Jogos On-line</li></ul><p>Algumas aplicações, como jogos on-line ou VOIP, podem tolerar alguma perda de dados. Se estas aplicações usarem TCP, elas podem passar por grandes atrasos enquanto o TCP detecta a perda e retransmite dados. Estes atrasos seriam mais prejudiciais para a aplicação do que pequenas perdas de dados. Algumas aplicações, como o DNS, simplesmente irão tentar novamente a solicitação se não receberem resposta e, portanto, eles não precisarão do TCP para  garantir a entrega da mensagem.</p><p>O baixo overhead do UDP o torna muito desejável para tais aplicações.</p></content-text></page></topic> <topic type="" id="tl0604040200">
<title><content-text>Reagrupamento de Datagramas UDP</content-text></title>
<page type="OneColumn" id="tl0604040201"><content-media type="StaticGraphic" id="cm8289536631"><title><content-text></content-text></title><media ref="tl0604000000/tl0604040000/tl0604040200/tl0604040201/cm8289536631.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604040000/tl0604040200/tl0604040201/cm8289536631text.xml"/></content-media> <content-text><p>Por causa do UDP ser sem conexão, as sessões não são estabelecidas antes que a comunicação ocorra enquanto elas estão com TCP. Diz-se que o UDP é baseado em transação. Em outras palavras, quando uma aplicação tem dados para enviar, ele simplesmente envia os dados.</p><p>Muitas aplicações que usam o UDP enviam pequenas quantidades de dados que podem se ajustar a um segmento. No entanto, algumas aplicações enviarão quantidades maiores de dados que precisam ser divididos em múltiplos segmentos. A PDU UDP é referida como um <i>datagrama</i>, embora os termos <i>segmento</i> e <i>datagrama</i> sejam usados algumas vezes de modo alternado para descrever uma PDU da camada de Transporte.</p><p>Quando múltiplos datagramas são enviados a um destino, eles podem tomar diferentes caminhos e chegar na ordem errada. O UDP não rastreia os números de sequência da forma que o TCP faz. O UDP não tem um modo para reordenar os datagramas na sua ordem de transmissão. Veja a figura.</p><p>Portanto, o UDP simplesmente reagrupa os dados na ordem que eles foram recebidos e os encaminha para a aplicação. Se a sequência dos dados é importante para a aplicação, ele terá que identificar a sequência apropriada dos dados e determinar como os dados devem ser processados.</p></content-text></page></topic> <topic type="" id="tl0604040300">
<title><content-text>Solicitações UDP e Processos de Servidores</content-text></title>
<page type="OneColumn" id="tl0604040301"><content-media type="StaticGraphic" id="cm5610122475"><title><content-text></content-text></title><media ref="tl0604000000/tl0604040000/tl0604040300/tl0604040301/cm5610122475.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604040000/tl0604040300/tl0604040301/cm5610122475text.xml"/></content-media> <content-text><p>Do mesmo modo que com as aplicações baseadas em TCP, aos aplicações de servidores baseados em UDP são designados números de porta Conhecida ou Registrada. Quando estas aplicações ou processos estão sendo executados, eles aceitarão os dados correspondentes ao número de porta designado. Quando o UDP recebe um datagrama destinado a uma destas portas, ele encaminha os dados à aplicação apropriada com base em seu número de porta.</p></content-text></page></topic> <topic type="" id="tl0604040400">
<title><content-text>Processos de Cliente UDP</content-text></title>
<page type="OneColumn" id="tl0604040401"><content-media type="StaticGraphic" id="cm5470588295"><title><content-text></content-text></title><media ref="tl0604000000/tl0604040000/tl0604040400/tl0604040401/cm5470588295.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604040000/tl0604040400/tl0604040401/cm5470588295text.xml"/></content-media> <content-text><p>Do mesmo modo que o TCP, a comunicação cliente/servidor é iniciada por uma aplicação cliente que está solicitando dados de um processo servidor. O processo cliente UDP seleciona aleatoriamente um número de porta a partir de uma faixa dinâmica de números de porta e o usa como a porta de origem para a conversação. A porta de destino será geralmente o número de porta Conhecida ou Registrada designado ao processo do servidor. </p><p>Números de porta de origem randomizados também ajudam na segurança. Se há um padrão previsível para seleção da porta de destino, um intruso pode simular um acesso a um cliente mais facilmente tentando conectar-se ao número de porta mais provável de ser aberto.</p><p>Por não haver sessão a ser criada com o UDP, tão logo os dados estejam prontos para serem enviados e a portas identificadas, o UDP pode formar o datagrama e passá-lo para a camada de Rede para ser endereçado e enviado pela rede.</p><p>Lembre-se, uma vez que o cliente escolheu as portas de origem e destino, o mesmo par de portas é usado no cabeçalho de todos os datagramas da transação. Para dados que retornam para o cliente a partir do servidor, os números de porta de origem e destino no cabeçalho do datagrama são invertidos.</p></content-text></page> <page type="OneColumn" id="tl0604040402"><content-media type="ActivityPKA" id="cm5755548362"><title><content-text></content-text></title><media ref="tl0604000000/tl0604040000/tl0604040400/tl0604040402/cm5755548362/" mime="application/packettracer" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604040000/tl0604040400/tl0604040402/cm5755548362/icontext.xml"/></content-media> <content-text><p>Nesta atividade, verifique como o DNS usa o UDP. </p><p><b>Clique no ícone do Packet Tracer para iniciar a atividade.</b></p></content-text></page></topic></section> <section type="" id="tl0604050000">
<title><content-text>Atividades de Laboratório</content-text></title>
<topic type="" id="tl0604050100">
<title><content-text>Observando TCP e UDP usando Netstat</content-text></title>
<page type="OneColumn" id="tl0604050101"><content-media type="ActivityLab" id="cm6014232153"><title><content-text></content-text></title><media ref="tl0604000000/tl0604050000/tl0604050100/tl0604050101/cm6014232153/" mime="application/pdf" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604050000/tl0604050100/tl0604050101/cm6014232153/icontext.xml"/></content-media> <content-text><p>Nesta sessão de laboratório, você examinará o comando <span class="cmd"><b>netstat</b></span> (network statistics utility) em um computador host, e ajustará as opções de saída do <span class="cmd"><b>netstat</b></span> para analisar e entender o status do protoloco da camada de Transporte TCP/IP.</p><p><b>Clique no ícone do Laboratório para ver mais detalhes.</b></p></content-text></page></topic> <topic type="" id="tl0604050200">
<title><content-text>Protocolos da Camada de Transporte TCP/IP, TCP e UDP</content-text></title>
<page type="OneColumn" id="tl0604050201"><content-media type="ActivityLab" id="cm5665071033"><title><content-text></content-text></title><media ref="tl0604000000/tl0604050000/tl0604050200/tl0604050201/cm5665071033/" mime="application/pdf" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604050000/tl0604050200/tl0604050201/cm5665071033/icontext.xml"/></content-media> <content-text><p>Nesta sessão de laboratório, você usará o Wireshark para capturar e identificar os campos do cabeçalho TCP, a operação durante uma sessão FTP, e campos do cabeçalho UDP e operação durante uma sessão TFTP.</p><p><b>Clique no ícone do Laboratório para ver mais detalhes.</b></p></content-text></page></topic> <topic type="" id="tl0604050300">
<title><content-text>Protocolos das Camadas de Aplicação e Transporte</content-text></title>
<page type="OneColumn" id="tl0604050301"><content-media type="ActivityLab" id="cm3014762274"><title><content-text></content-text></title><media ref="tl0604000000/tl0604050000/tl0604050300/tl0604050301/cm3014762274/" mime="application/pdf" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604050000/tl0604050300/tl0604050301/cm3014762274/icontext.xml"/></content-media> <content-text><p>Nesta sessão de laboratório, você usará o Wireshark para monitorar e analisar as comunicações da aplicação cliente (FTP e HTTP) entre um servidor e clientes.</p><p><b>Clique no ícone do Laboratório para ver mais detalhes.</b></p></content-text></page> <page type="OneColumn" id="tl0604050302"><content-media type="ActivityPKA" id="cm4324308257"><title><content-text></content-text></title><media ref="tl0604000000/tl0604050000/tl0604050300/tl0604050302/cm4324308257/" mime="application/packettracer" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604050000/tl0604050300/tl0604050302/cm4324308257/icontext.xml"/></content-media> <content-text><p>Nesta atividade, você usará o modo de Simulação de Packet Tracer para capturar e analisar uma solicitação web usando uma URL.</p><p><b>Clique no ícone do Packet Tracer para iniciar a atividade.</b></p></content-text></page></topic></section> <section type="ChapterSummary" id="tl0604060000">
<title><content-text>Resumo do Capítulo</content-text></title>
<topic type="" id="tl0604060100">
<title><content-text>Resumo e Revisão</content-text></title>
<page type="OneColumn" id="tl0604060101"><content-media type="StaticGraphic" id="cm1262585397"><title><content-text></content-text></title><media ref="tl0604000000/tl0604060000/tl0604060100/tl0604060101/cm1262585397.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604060000/tl0604060100/tl0604060101/cm1262585397text.xml"/></content-media> <content-text><p>A camada de Transporte provê as necessidades da rede de dados através de:</p><ul><li> Divisão de dados recebidos de uma aplicação em segmentos</li><li> Adição de um cabeçalho para identificar e gerenciar cada segmento</li><li> Uso da informação do cabeçalho para reagrupar os segmentos de volta nos dados da aplicação</li><li> Transmitir os dados agrupados para a aplicação correta</li></ul><p>O UDP e o TCP são os protocolos da camada de Transporte mais comuns.</p><p>Os datagramas UDP e os segmentos TCP têm cabeçalhos pré-fixados aos dados que incluem o número de porta de origem e o número de porta de destino. Estes números de porta habilitam os dados a serem redirecionados para a aplicação correta sendo executada no computador de destino.</p><p>O TCP não passa qualquer dado para a rede até que saiba que o destino está pronto para recebê-lo. O TCP então gerencia o fluxo de dados e reenvia quaisquer segmentos de dados que não são confirmados conforme sejam recebidos no destino. O TCP usa mecanismos de handshake triplo, temporizador e confirmações, e janelamento dinâmico para alcançar estas características confiáveis. Esta confiabilidade, no entanto, impõe uma sobrecarga na rede em termos de cabeçalhos de segmentos muito maior e mais tráfego de rede entre a origem e o destino no gerenciamento do transporte de dados. </p><p>Se os dados da aplicação precisam ser entregues rapidamente pela rede, ou se a largura de banda da rede não suporta a sobrecarga ou overhead de mensagens de controle sendo trocadas entre os sistemas de origem e destino, o UDP será o protocolo da camada de Transporte preferido pelo programador. Devido ao fato do UDP não rastrear ou confirmar o recebimento de datagramas no destino - ele apenas passa os datagramas recebidos para a camada de Aplicação à medida que eles chegam - e não reenvia datagramas perdidos. No entanto, isto não significa necessariamente que a comunicação em si não seja confiável; pode haver mecanismos nos protocolos e serviços da camada de Aplicação que processam datagramas perdidos ou com atraso se a aplicação tem estas necessidades.</p><p>A escolha do protocolo da camada de Transporte é feito pelo programador da aplicação para melhor satisfazer as necessidades do usuário. O programador tem em mente que, apesar disso, todas as outras camadas têm um papel nas comunicações de rede de dados e influenciarão o seu desempenho. </p></content-text></page> <page type="FullScreen" id="tl0604060102"><content-media type="ChapterSummary" id="cm9371573563"><title><content-text></content-text></title><media ref="tl0604000000/tl0604060000/tl0604060100/tl0604060102/cm9371573563.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604060000/tl0604060100/tl0604060102/cm9371573563text.xml"/></content-media> <content-text></content-text></page> <page type="OneColumn" id="tl0604060103"><content-media type="ActivityPKA" id="cm1581086500"><title><content-text></content-text></title><media ref="tl0604000000/tl0604060000/tl0604060100/tl0604060103/cm1581086500/" mime="application/packettracer" scale="true" type="directory" width="0" height="0" external="tl0604000000/tl0604060000/tl0604060100/tl0604060103/cm1581086500/icontext.xml"/></content-media> <content-text><p>Nesta atividade, processo que ocorre cada vez que você solicita uma página web da Internet - a interação DNS, HTTP, UDP e TCP - é examinada em profundidade.  </p><p><content-link target="E1_PTAct_4_6_1_Directions.pdf" type="internalfile">Instruções de Integração de Habilidades do Packet Tracer (PDF)</content-link></p><p><b>Clique no ícone do Packet Tracer para iniciar a atividade.</b></p></content-text></page> <page type="OneColumn" id="tl0604060104"><content-media type="StaticGraphic" id="cm4983274047"><title><content-text></content-text></title><media ref="tl0604000000/tl0604060000/tl0604060100/tl0604060104/cm4983274047.swf" mime="shockwave/flash" scale="true" type="file" width="400" height="200" external="tl0604000000/tl0604060000/tl0604060100/tl0604060104/cm4983274047text.xml"/></content-media> <content-text><p><b>Para aprender mais</b></p><p><b>Questões para Reflexão</b></p><p>Discuta as necessidades de uma aplicação da camada de Aplicação que determine se o programador selecionou o UDP ou o TCP como o protocolo da camada de Transporte a ser usado.</p><p>Se uma aplicação de rede exigiu que seus dados sejam entregues confiavelmente, discuta como o UDP poderia ser usado como protocolo da camada de Transporte e sob quais circunstâncias isso seria usado. </p><p><b>Links</b></p><p>Introdução a Conexão de Redes</p><p><content-link target="http://www.cisco.com/univercd/cc/td/doc/cisintwk/ito_doc/introint.htm" type="external">http://www.cisco.com/univercd/cc/td/doc/cisintwk/ito_doc/introint.htm</content-link></p></content-text></page></topic></section> <section type="ChapterQuiz" id="tl0604070000">
<title><content-text>Teste do Capítulo</content-text></title>
<topic type="" id="tl0604070100">
<title><content-text>Teste do Capítulo</content-text></title>
<page type="FullScreen" id="tl0604070101"><content-media type="ChapterQuiz" id="cm1086891551"><title><content-text></content-text></title><media ref="tl0604000000/tl0604070000/tl0604070100/tl0604070101/cm1086891551/" mime="" scale="true" type="directory" width="100%" height="100%" external="tl0604000000/tl0604070000/tl0604070100/tl0604070101/cm1086891551/icontext.xml"/></content-media> <content-text></content-text></page></topic></section></chapter>
